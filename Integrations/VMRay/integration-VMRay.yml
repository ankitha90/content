category: Forensics & Malware Analysis
commonfields:
  id: vmray2
  version: -1
configuration:
- defaultvalue: https://cloud.vmray.com/
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  type: 0
- display: API-Key
  name: api_key
  required: false
  type: 4
- display: Use system proxy
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
description: Ransomware analysis sandboxing
display: VMRay2
name: vmray2
script:
  commands:
  - arguments:
    - default: false
      description: Entry id  of file to submit
      isArray: false
      name: entry_id
      required: true
      secret: false
    - default: false
      description: Password of the document
      isArray: false
      name: document_password
      required: false
      secret: false
    - default: false
      description: password of an archive
      isArray: false
      name: archive_password
      required: false
      secret: false
    - default: false
      description: Force type of file
      isArray: false
      name: sample_type
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Make the file shareable
      isArray: false
      name: shareable
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Analyze no matter if analyses already exist
      isArray: false
      name: reanalyze
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: Maximum jobs to be created (number)
      isArray: false
      name: max_jobs
      required: false
      secret: false
    - default: false
      description: Tags to add to sample (comma seperated)
      isArray: false
      name: tags
      required: false
      secret: false
    deprecated: false
    description: Submit sample to VMRay
    execution: false
    name: vmray-upload-sample
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of a new job
      type: Number
    - contextPath: VMRay.Job.Created
      description: Timestamp of created job
      type: Date
    - contextPath: VMRay.Job.SampleID
      description: ID of sample
      type: Number
    - contextPath: VMRay.Job.VMName
      description: Name of virtual machine
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of virtual machine
      type: Number
    - contextPath: VMRay.Sample.SampleID
      description: ID of sample
      type: Number
    - contextPath: VMRay.Sample.Created
      description: Timestamp of created sample
      type: Date
    - contextPath: VMRay.Submission.SubmissionID
      description: Submission ID
      type: Number
  - arguments:
    - default: false
      description: Analysis sample ID
      isArray: false
      name: sample_id
      required: true
      secret: false
    - default: false
      description: Limits results (number)
      isArray: false
      name: limit
      required: false
      secret: false
    deprecated: false
    description: Get all analysis details about a specific sample.
    execution: false
    name: vmray-get-analysis-by-sample
    outputs:
    - contextPath: VMRay.Analysis.AnalysisID
      description: ID of analysis
      type: Number
    - contextPath: VMRay.Analysis.SampleID
      description: Sample ID in analysis
      type: Number
    - contextPath: VMRay.Analysis.Severity
      description: Severity of sample (Malicious, Suspicious, Good, Blacklisted, Whitelested,
        Unknown)
      type: String
    - contextPath: VMRay.Analysis.JobCreated
      description: Analysis job started
      type: Date
    - contextPath: VMRay.Analysis.MD5
      description: MD5 of sample
      type: String
    - contextPath: VMRay.Analysis.SHA1
      description: SHA1 of sample
      type: String
    - contextPath: VMRay.Analysis.SHA256
      description: SHA256 of sample
      type: String
    - contextPath: VMRay.Analysis.SSDeep
      description: SSDeep of sample
      type: String
  - arguments:
    - default: false
      description: Job sample id
      isArray: false
      name: sample_id
      required: true
      secret: false
    deprecated: false
    description: Get all jobs details about a specific sample.
    execution: false
    name: vmray-get-job-by-sample
    outputs:
    - contextPath: VMRay.Job.JobID
      description: ID of job
      type: Number
    - contextPath: VMRay.Job.SampleID
      description: Sample ID of job
      type: Number
    - contextPath: VMRay.Job.SubmissionID
      description: ID of submission
      type: Number
    - contextPath: VMRay.Job.MD5
      description: MD5 of sample in job
      type: String
    - contextPath: VMRay.Job.SHA1
      description: SHA1 of sample in job
      type: String
    - contextPath: VMRay.Job.SHA256
      description: SHA256 of sample in job
      type: String
    - contextPath: VMRay.Job.SSDeep
      description: SSDeep of sample in job
      type: String
    - contextPath: VMRay.Job.VMName
      description: Name of virtual machine
      type: String
    - contextPath: VMRay.Job.VMID
      description: ID of virtual machine
      type: Number
    - contextPath: VMRay.Job.Status
      description: 'Status of job. '
      type: String
  - arguments:
    - default: false
      description: ID of submission (can be aquired from vmray-upload-sample)
      isArray: false
      name: submission_id
      required: true
      secret: false
    deprecated: false
    description: Gets a submission result
    execution: false
    name: vmray-get-submission
    outputs:
    - contextPath: VMRay.Submission.IsFinished
      description: Status of submission (true or false)
      type: Boolean
    - contextPath: VMRay.Submission.HasErrors
      description: If there are any errors in the submission
      type: Boolean
    - contextPath: VMRay.Submission.SubmissionID
      description: ID of of sample in submission
      type: Number
    - contextPath: VMRay.Submission.MD5
      description: MD5 of of sample in submission
      type: String
    - contextPath: VMRay.Submission.SHA1
      description: SHA1 of of sample in submission
      type: String
    - contextPath: VMRay.Submission.SHA256
      description: SHA256 of of sample in submission
      type: String
    - contextPath: VMRay.Submission.SSDeep
      description: SSDeep of of sample in submission
      type: String
    - contextPath: VMRay.Submission.Severity
      description: Severity of sample in submission (Malicious, Suspicious, Good,
        Blacklisted, Whitelested, Unknown)
      type: String
    - contextPath: VMRay.Submission.SampleID
      description: ID of sample in submission
      type: Number
  - arguments:
    - default: false
      description: 'id of sample '
      isArray: false
      name: sample_id
      required: true
      secret: false
    deprecated: false
    description: get sample by sample id
    execution: false
    name: vmray-get-sample
    outputs:
    - contextPath: VMRay.Sample.SampleID
      description: ID of sample
      type: Number
    - contextPath: VMRay.Sample.FileName
      description: File name of sample
      type: String
    - contextPath: VMRay.Sample.MD5
      description: MD5 of sample
      type: String
    - contextPath: VMRay.Sample.SHA1
      description: SHA1 of sample
      type: String
    - contextPath: VMRay.Sample.SHA256
      description: SHA256 of sample
      type: String
    - contextPath: VMRay.Sample.SSDeep
      description: SSDeep of sample
      type: String
    - contextPath: VMRay.Sample.Severity
      description: Severity of sample in submission (Malicious, Suspicious, Good,
        Blacklisted, Whitelested, Unknown)
      type: String
    - contextPath: VMRay.Sample.Type
      description: File type
      type: String
    - contextPath: VMRay.Sample.Created
      description: timestamp of created sample
      type: Date
    - contextPath: VMRay.Sample.Classifications
      description: Classifications of sample
      type: String
  - arguments:
    - default: false
      description: ID of sample (can get from VMRay.Sample.ID)
      isArray: false
      name: sample_id
      required: true
      secret: false
    deprecated: false
    description: Get threat indicators (VTI)
    execution: false
    name: vmray-get-threat-indicators
    outputs:
    - contextPath: VMRay.ThreatIndicator.AnalysisID
      description: List of connected analyses ids
      type: Number
    - contextPath: VMRay.ThreatIndicator.Category
      description: Category of threat indicators
      type: String
    - contextPath: VMRay.ThreatIndicator.Classification
      description: Classifications of threat indicators
      type: String
    - contextPath: VMRay.ThreatIndicator.ID
      description: ID of threat indicator
      type: Number
    - contextPath: VMRay.ThreatIndicator.Operation
      description: Operation the indicators caused
      type: String
  - arguments:
    - default: false
      description: ID of submission to add tag to
      isArray: false
      name: submission_id
      required: false
      secret: false
    - default: false
      description: ID of analysis to delete tag from
      isArray: false
      name: analysis_id
      required: false
      secret: false
    - default: false
      description: Tag to add
      isArray: false
      name: tag
      required: false
      secret: false
    deprecated: false
    description: Adds a tag to analysis and/or submission
    execution: false
    name: vmray-add-tag
  - arguments:
    - default: false
      description: ID of analysis to delete tag from
      isArray: false
      name: analysis_id
      required: false
      secret: false
    - default: false
      description: ID of submission to delete tag from
      isArray: false
      name: submission_id
      required: false
      secret: false
    - default: false
      description: Tag to delete
      isArray: false
      name: tag
      required: false
      secret: false
    deprecated: false
    description: Delete tags from analysis and/or submission
    execution: false
    name: vmray-delete-tag
  - arguments:
    - default: false
      description: if of sample
      isArray: false
      name: sample_id
      required: true
      secret: false
    deprecated: false
    description: getting iocs of given sample
    execution: false
    name: vmray-get-iocs
    outputs:
    - contextPath: VMRay.Sample.IOC.URL.AnalysisID
      description: IDs of other analyses conatining given URL
      type: Number
    - contextPath: VMRay.Sample.IOC.URL.URL
      description: URL
      type: String
    - contextPath: VMRay.Sample.IOC.URL.Operation
      description: Operation of given url
      type: String
    - contextPath: VMRay.Sample.IOC.URL.ID
      description: ID of URL
      type: Number
    - contextPath: VMRay.Sample.IOC.URL.Type
      description: Type of url
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.AnalysisID
      description: IDs of other analyses conatining given Domain
      type: Number
    - contextPath: VMRay.Sample.IOC.Domain.Domain
      description: Domain
      type: String
    - contextPath: VMRay.Sample.IOC.Domain.ID
      description: ID of domain
      type: Number
    - contextPath: VMRay.Sample.IOC.Domain.Type
      description: Type of domain
      type: String
    - contextPath: VMRay.Sample.IOC.IP.AnalysisID
      description: IDs of other analyses conatining given IP
      type: Number
    - contextPath: VMRay.Sample.IOC.IP.IP
      description: IP
      type: String
    - contextPath: VMRay.Sample.IOC.IP.Operation
      description: Operation of given IP
      type: String
    - contextPath: VMRay.Sample.IOC.IP.ID
      description: ID of IP
      type: Number
    - contextPath: VMRay.Sample.IOC.IP.Type
      description: Type of IP
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.AnalysisID
      description: IDs of other analyses conatining given IP
      type: Number
    - contextPath: VMRay.Sample.IOC.Mutex.Name
      description: Name of mutex
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.Operation
      description: Operation of given mutex
      type: String
    - contextPath: VMRay.Sample.IOC.Mutex.ID
      description: ID of mutex
      type: Number
    - contextPath: VMRay.Sample.IOC.Mutex.Type
      description: Type of mutex
      type: String
  dockerimage: demisto/python
  isfetch: false
  runonce: false
  script: |-
    import os
    import requests
    from CommonServerPython import *
    import demistomock as demisto

    """ GLOBAL PARAMS """
    API_KEY = demisto.params()["api_key"]
    SERVER = (
        demisto.params()["server"][:-1]
        if (demisto.params()["server"] and demisto.params()["server"].endswith("/"))
        else demisto.params()["server"]
    )

    SERVER += "/rest/"
    USE_SSL = not demisto.params().get("insecure", False)
    HEADERS = {"Authorization": "api_key " + API_KEY}

    # Remove proxy
    if not demisto.params().get("proxy"):
        del os.environ["HTTP_PROXY"]
        del os.environ["HTTPS_PROXY"]
        del os.environ["http_proxy"]
        del os.environ["https_proxy"]

    """ HELPER DICTS """
    SEVERITY_DICT = {
        "malicious": "Malicious",
        "suspicious": "Suspicious",
        "not_suspicious": "Good",
        "blacklisted": "Blacklisted",
        "whitelisted": "Whitelisted",
        "unknown": "Unknown",
        None: "Unknown"
    }

    DBOTSCORE = {
        "Malicious": 3,
        "Suspicious": 2,
        "Good": 1,
        "Blacklisted": 3,
        "Whitelisted": 1,
        "Unknown": 0,
    }

    """ HELPER FUNCTIONS """


    def http_request(method, url_suffix, body=None, params=None, files=None, ignore_error=False):
        """ General HTTP request.
        Args:
            ignore_error:
            method: (str) "GET", "POST", "DELETE' "PUT"
            url_suffix: (str)
            body: (dict)
            params: (dict)
            files: (tuple, dict)

        Returns:
            dict: response json
        """

        url = SERVER + url_suffix
        r = requests.request(
            method,
            url,
            json=body,
            params=params,
            headers=HEADERS,
            files=files,
            verify=USE_SSL,
        )
        if r.status_code not in {200, 201, 202, 204} and not ignore_error:
            error = str()
            try:
                js = r.json()
                error += js.get("error_msg")
            except ValueError:
                error = r.text
            return_error(
                "Error in API call to VMRay [{}] - {}".format(r.status_code, error)
            )
        return r.json()


    def score_by_hash(analysis):
        """Gets a dict containing MD5/SHA1/SHA256/SSDeep and return dbotscore

        Args:
            analysis: (dict)

        Returns:
            dict: dbot score
        """
        hashes = ["MD5", "SHA256", "SHA1", "SSDeep"]
        scores = list()
        for hash_type in hashes:
            if hash_type in analysis:
                scores.append(
                    {
                        "Indicator": analysis.get(hash_type),
                        "Type": "hash",
                        "Vendor": "VMRay",
                        "Score": DBOTSCORE.get(analysis.get("Severity", 0)),
                    }
                )
        return scores


    def build_job_data(data):
        def build_entry(entry_data):
            entry = dict()
            entry["JobID"] = entry_data.get("job_id")
            entry["SampleID"] = entry_data.get("job_sample_id")
            entry["SubmissionID"] = entry_data.get("job_submission_id")
            entry["MD5"] = entry_data.get("job_sample_md5")
            entry["SHA1"] = entry_data.get("job_sample_sha1")
            entry["SHA256"] = entry_data.get("job_sample_sha256")
            entry["SSDeep"] = entry_data.get("job_sample_ssdeep")
            entry["VMName"] = entry_data.get("job_vm_name")
            entry["VMID"] = entry_data.get("job_vm_id")
            entry["Status"] = entry_data.get("job_status")
            return entry

        jobs_list = list()
        if isinstance(data, list):
            for entry in data:
                jobs_list.append(build_entry(entry))
        elif isinstance(data, dict):
            jobs_list = build_entry(data)
        return jobs_list


    def build_finished_job(job_id, sample_id):
        entry = dict()
        entry["JobID"] = job_id
        entry["SampleID"] = sample_id
        entry["Status"] = "Finished/NotExists"
        return entry


    def build_analysis_data(analyses):
        """

        Args:
            analyses: (dict) of analysis

        Returns:
            dict: formatted entry context
        """
        entry_context = dict()
        entry_context["VMRay.Analysis(val.AnalysisID === obj.AnalysisID)"] = [
            {
                "AnalysisID": analysis.get("analysis_id"),
                "SampleID": analysis.get("analysis_sample_id"),
                "Severity": SEVERITY_DICT.get(analysis.get("analysis_severity")),
                "JobCreated": analysis.get("analysis_job_started"),
                "SHA1": analysis.get("analysis_sample_sha1"),
                "MD5": analysis.get("analysis_sample_md5"),
                "SHA256": analysis.get("analysis_sample_sha25"),
            }
            for analysis in analyses
        ]

        scores = list()
        for analysis in entry_context:
            scores.extend(score_by_hash(analysis))
        entry_context[outputPaths.get("dbotscore")] = scores

        return entry_context


    def test_module():
        """Simple get request to see if connected
        """
        http_request("GET", "analysis?_limit=1")
        demisto.results("ok")


    def upload_sample(path, params=None):
        suffix = "sample/submit"
        files = {"sample_file": open(path, "rb")}
        results = http_request("POST", url_suffix=suffix, params=params, files=files)
        return results


    def upload_sample_command():
        """Uploads a file to vmray
        """
        # Preserve BC
        file_id = demisto.args().get("entry_id") if demisto.args().get("entry_id") else demisto.args().get("file_id")
        path = demisto.getFilePath(file_id).get("path")

        # additional params
        doc_pass = demisto.args().get("document_password")
        arch_pass = demisto.args().get("archive_password")
        sample_type = demisto.args().get("sample_type")
        shareable = demisto.args().get("shareable")
        reanalyze = demisto.args().get("reanalyze")
        max_jobs = demisto.args().get("max_jobs")
        tags = demisto.args().get("tags")

        params = dict()
        if doc_pass:
            params["document_password"] = doc_pass
        if arch_pass:
            params["archive_password"] = arch_pass
        if sample_type:
            params["sample_type"] = sample_type
        if shareable == "true":
            params["shareable"] = shareable
        if reanalyze == "true":
            params["reanalyze"] = reanalyze
        if max_jobs:
            if max_jobs.isdigit():
                params["max_jobs"] = int(max_jobs)
            else:
                return_error("max_jobs arguments isn't a number")
        if tags:
            params["tags"] = tags

        # Request call
        raw_response = upload_sample(path, params=params)
        data = raw_response.get("data")
        jobs_list = list()
        jobs = data.get("jobs")
        if jobs:
            for job in jobs:
                if isinstance(job, dict):
                    job_entry = dict()
                    job_entry["JobID"] = job.get("job_id")
                    job_entry["Created"] = job.get("job_created")
                    job_entry["SampleID"] = job.get("job_sample_id")
                    job_entry["VMName"] = job.get("job_vm_name")
                    job_entry["VMID"] = job.get("job_vm_id")
                    job_entry["JobRuleSampleType"] = job.get("job_jobrule_sampletype")
                    jobs_list.append(job_entry)

        samples_list = list()
        samples = data.get("samples")
        if samples:
            for sample in samples:
                if isinstance(sample, dict):
                    sample_entry = dict()
                    sample_entry["SampleID"] = sample.get("sample_id")
                    sample_entry["Created"] = sample.get("sample_created")
                    sample_entry["FileName"] = sample.get("submission_filename")
                    sample_entry["FileSize"] = sample.get("sample_filesize")
                    sample_entry["SSDeep"] = sample.get("sample_ssdeephash")
                    sample_entry["SHA1"] = sample.get("sample_sha1hash")
                    samples_list.append(sample_entry)

        submissions_list = list()
        submissions = data.get("submissions")
        if submissions:
            for submission in submissions:
                if isinstance(submission, dict):
                    submission_entry = dict()
                    submission_entry["SubmissionID"] = submission.get("submission_id")
                    submission_entry["SampleID"] = submission.get("submission_sample_id")
                    submissions_list.append(submission_entry)

        entry_context = dict()
        entry_context["VMRay.Job(val.JobID === obj.JobID)"] = jobs_list
        entry_context["VMRay.Sample(val.SampleID === obj.SampleID)"] = samples_list
        entry_context["VMRay.Submission(val.SubmissionID === obj.SubmissionID)"] = submissions_list

        table = {
            "Jobs ID": [job.get("JobID") for job in jobs_list],
            "Samples ID": [sample.get("SampleID") for sample in samples_list],
            "Submissions ID": [
                submission.get("SubmissionID") for submission in submissions_list
            ],
        }
        human_readable = tableToMarkdown(
            "File submitted to VMRay",
            t=table,
            headers=["Jobs ID", "Samples ID", "Submissions ID"],
        )

        return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)


    def get_analysis_command():
        sample_id = demisto.args().get("sample_id")
        limit = demisto.args().get("limit")

        params = {"_limit": limit}
        raw_response = get_analysis(sample_id, params)
        data = raw_response.get("data")
        entry_context = build_analysis_data(data)
        humam_readable = json.dumps(entry_context, indent=4)
        return_outputs(humam_readable, entry_context, raw_response=raw_response)


    def get_analysis(sample, params=None):
        suffix = "analysis/sample/{}".format(sample)
        response = http_request("GET", suffix, params=params)
        return response


    def get_submission_command():
        submission_id = demisto.args().get("submission_id")
        raw_response = get_submission(submission_id)
        data = raw_response.get("data")
        if data:
            demisto.results(data)
            # Build entry
            entry = dict()
            entry["IsFinished"] = data.get("submission_finished")
            entry["HasErrors"] = data.get("submission_has_errors")
            entry["SubmissionID"] = data.get("submission_id")
            entry["MD5"] = data.get("submission_sample_md5")
            entry["SHA1"] = data.get("submission_sample_sha1")
            entry["SHA256"] = data.get("submission_sample_sha256")
            entry["SSDeep"] = data.get("submission_sample_ssdeep")
            entry["Severity"] = SEVERITY_DICT.get(data.get("submission_severity"))
            entry["SampleID"] = data.get("submission_sample_id")
            scores = score_by_hash(entry)

            entry_context = {
                "VMRay.Submission(val.SubmissionID === obj.SubmissionID)": entry,
                outputPaths.get("dbotscore"): scores,
            }

            human_readable = tableToMarkdown(
                "Submission results from VMRay for ID {} with severity of {}".format(
                    submission_id, entry.get("Severity", "Unknown")
                ),
                entry,
                headers=[
                    "IsFinished",
                    "Severity",
                    "HasErrors",
                    "MD5",
                    "SHA1",
                    "SHA256",
                    "SSDeep",
                ],
            )

            return_outputs(human_readable, entry_context, raw_response=raw_response)
        else:
            return_outputs("No submission found in VMRay for submission id: {}".format(submission_id), {})


    def get_submission(submission_id):
        """

        Args:
            submission_id: (str)

        Returns:
            dict: response.data
        """
        suffix = "submission/{}".format(submission_id)
        response = http_request("GET", url_suffix=suffix)
        return response


    def get_sample_command():
        sample_id = demisto.args().get("sample_id")
        raw_response = get_sample(sample_id)
        data = raw_response.get("data")

        entry = dict()
        entry["SampleID"] = data.get("sample_id")
        entry["FileName"] = data.get("sample_filename")
        entry["MD5"] = data.get("sample_md5hash")
        entry["SHA1"] = data.get("sample_sha1hash")
        entry["SHA256"] = data.get("sample_sha256hash")
        entry["SSDeep"] = data.get("sample_ssdeephash")
        entry["Severity"] = SEVERITY_DICT.get(data.get("sample_severity"))
        entry["Type"] = data.get("sample_type")
        entry["Created"] = data.get("sample_created")
        entry["Classification"] = data.get("sample_classifications")
        scores = score_by_hash(entry)

        entry_context = {
            "VMRay.Sample(var.SampleID === obj.SampleID)": entry,
            outputPaths.get("dbotscore"): scores,
        }

        human_readable = tableToMarkdown(
            "Results for sample id: {} with severity {}".format(
                entry.get("SampleID"), entry.get("Severity")
            ),
            entry,
            headers=["Type", "MD5", "SHA1", "SHA256", "SSDeep"],
        )
        return_outputs(human_readable, entry_context, raw_response=raw_response)


    def get_sample(sample_id):
        """building http request for get_sample_command

        Args:
            sample_id: (str, int)

        Returns:
            dict: data from response
        """
        suffix = "sample/{}".format(sample_id)
        response = http_request("GET", suffix)
        return response


    def get_job_sample(sample_id):
        """
        Args:
            sample_id:

        Returns:
            dict of response, if not exists returns:
            {
                "error_msg": "No such element"
                "result": "error"
            }
        """
        suffix = "job/sample/{}".format(sample_id)
        response = http_request("GET", suffix, ignore_error=True)
        return response


    def get_job_sample_command():
        sample_id = demisto.args().get("sample_id")
        raw_response = get_job_sample(sample_id)
        data = raw_response.get("data")

        if raw_response.get("result") == "error":
            entry = build_finished_job(job_id=None, sample_id=sample_id)
            human_readable = "Jobs for sample id {} is finished/not exists".format(sample_id)
        else:
            entry = build_job_data(data)
            sample = entry[0] if isinstance(entry, list) else entry
            human_readable = tableToMarkdown(
                "Results for job sample id: {}".format(sample_id),
                sample,
                headers=["JobID", "SampleID", "VMName", "VMID"],
            )

        entry_context = {"VMRay.Job(val.JobID === obj.JobID)": entry}

        return_outputs(human_readable, entry_context, raw_response=raw_response)


    def get_job_by_id(job_id):
        suffix = "job/{}".format(job_id)
        response = http_request("GET", suffix, ignore_error=True)
        return response


    def get_job_by_id_command():
        job_id = demisto.args().get("job_id")
        raw_response = get_job_by_id(job_id)
        if raw_response.get("result") == "error":
            entry = build_finished_job(job_id, sample_id=None)
            human_readable = "Jobs for job id {} is finished/not exists".format(job_id)
        else:
            data = raw_response.get("data")
            entry = build_job_data(data)
            sample = entry[0] if isinstance(entry, list) else entry
            human_readable = tableToMarkdown(
                "Results for job sample id: {}".format(job_id),
                sample,
                headers=["JobID", "SampleID", "VMName", "VMID"],
            )

        entry_context = {"VMRay.Job(val.JobID === obj.JobID)": entry}
        return_outputs(human_readable, entry_context, raw_response=raw_response)


    def get_threat_indicators(sample_id):
        suffix = "sample/{}/threat_indicators".format(sample_id)
        response = http_request("GET", suffix).get("data")
        return response


    def get_threat_indicators_command():
        sample_id = demisto.args().get("sample_id")
        raw_response = get_threat_indicators(sample_id)
        data = raw_response.get("threat_indicators")

        # Build Entry Context
        if data and isinstance(data, list):
            entry_context_list = list()
            for indicator in data:
                entry = dict()
                entry["AnalysisID"] = indicator.get("analysis_ids")
                entry["Category"] = indicator.get("category")
                entry["Classification"] = indicator.get("classifications")
                entry["ID"] = indicator.get("id")
                entry["Operation"] = indicator.get("operation")
                entry_context_list.append(entry)

            human_readable = tableToMarkdown(
                "Threat indicators for sample ID: {}. Showing first indicator:".format(
                    sample_id
                ),
                entry_context_list[0],
                headers=["AnalysisID", "Category", "Classification", "Operation"],
            )

            entry_context = {"VMRay.ThreatIndicator(obj.ID === val.ID)": entry_context_list}
            return_outputs(human_readable, entry_context, raw_response={"threat_indicators": data})
        return_outputs(
            "No threat indicators for sample ID: {}".format(sample_id),
            {},
            raw_response=raw_response,
        )


    def post_tags_to_analysis(analysis_id, tag):
        suffix = "analysis/{}/tag/{}".format(analysis_id, tag)
        response = http_request("POST", suffix)
        return response


    def post_tags_to_submission(submission_id, tag):
        suffix = "submission/{}/tag/{}".format(submission_id, tag)
        response = http_request("POST", suffix)
        return response


    def post_tags():
        analysis_id = demisto.args().get("analysis_id")
        submission_id = demisto.args().get("submission_id")
        tag = demisto.args().get("tag")
        if not submission_id and not analysis_id:
            return_error("No submission ID or analysis ID has been provided")
        if analysis_id:
            analysis_status = post_tags_to_analysis(analysis_id, tag)
            if analysis_status.get("result") == "ok":
                return_outputs(
                    "Tags: {} has been added to analysis:".format(tag, analysis_id),
                    {},
                    raw_response=analysis_status,
                )
        if submission_id:
            submission_status = post_tags_to_submission(submission_id, tag)
            if submission_status.get("result") == "ok":
                return_outputs(
                    "Tags: {} has been added to submission:".format(tag, submission_id),
                    {},
                    raw_response=submission_status,
                )


    def delete_tags_from_analysis(analysis_id, tag):
        suffix = "analysis/{}/tag/{}".format(analysis_id, tag)
        response = http_request("DELETE", suffix)
        return response


    def delete_tags_from_submission(submission_id, tag):
        suffix = "submission/{}/tag/{}".format(submission_id, tag)
        response = http_request("DELETE", suffix)
        return response


    def delete_tags():
        analysis_id = demisto.args().get("analysis_id")
        submission_id = demisto.args().get("submission_id")
        tag = demisto.args().get("tags")
        if not submission_id and not analysis_id:
            return_error("No submission ID or analysis ID has been provided")
        if analysis_id:
            analysis_status = delete_tags_from_analysis(analysis_id, tag)
            if analysis_status.get("result") == "ok":
                return_outputs(
                    "Tags: {} has been added to analysis:".format(tag, analysis_id),
                    {},
                    raw_response=analysis_status,
                )
        if submission_id:
            submission_status = delete_tags_from_submission(submission_id, tag)
            if submission_status.get("result") == "ok":
                return_outputs(
                    "Tags: {} has been added to submission:".format(tag, submission_id),
                    {},
                    raw_response=submission_status,
                )


    def get_iocs(sample_id):
        suffix = "sample/{}/iocs".format(sample_id)
        response = http_request("GET", suffix)
        return response


    def get_iocs_command():
        sample_id = demisto.args().get("sample_id")
        raw_response = get_iocs(sample_id)
        data = raw_response.get("data").get("iocs")

        domains = data.get("domains")
        domain_list = list()
        if domains:
            for domain in domains:
                entry = dict()
                entry["AnalysisID"] = domain.get("analysis_ids")
                entry["Domain"] = domain.get("domain")
                entry["ID"] = domain.get("id")
                entry["Type"] = domain.get("type")
                domain_list.append(entry)

        ips = data.get("ips")
        ip_list = list()
        if ips:
            for ip in ips:
                entry = dict()
                entry["AnalysisID"] = ip.get("analysis_ids")
                entry["IP"] = ip.get("ip_address")
                entry["ID"] = ip.get("id")
                entry["Type"] = ip.get("type")
                ip_list.append(entry)

        mutexes = data.get("mutexes")
        mutex_list = list()
        if mutexes:
            for mutex in mutexes:
                entry = dict()
                entry["AnalysisID"] = mutex.get("analysis_ids")
                entry["Name"] = mutex.get("mutex_name")
                entry["Operation"] = mutex.get("operations")
                entry["ID"] = mutex.get("id")
                entry["Type"] = mutex.get("type")
                mutex_list.append(entry)

        registry = data.get("registry")
        registry_list = list()
        if registry:
            for reg in registry:
                entry = dict()
                entry["AnalysisID"] = reg.get("analysis_ids")
                entry["Name"] = reg.get("reg_key_name")
                entry["Operation"] = reg.get("operations")
                entry["ID"] = reg.get("id")
                entry["Type"] = reg.get("type")
                registry_list.append(entry)

        urls = data.get("urls")
        urls_list = list()
        if urls:
            for url in urls:
                entry = dict()
                entry["AnalysisID"] = url.get("analysis_ids")
                entry["URL"] = url.get("url")
                entry["Operation"] = url.get("operations")
                entry["ID"] = url.get("id")
                entry["Type"] = url.get("type")
                urls_list.append(entry)

        iocs = {
            "URL": urls_list,
            "Mutex": mutex_list,
            "Domain": domain_list,
            "Registry": registry_list,
            "IP": ip_list
        }

        entry_context = {
            "VMRay.Sample(val.SampleID == {}).IOC".format(sample_id): iocs,
        }

        # Get total size of iocs for HumanReadable
        iocs_size_table = dict()
        iocs_size = 0
        for k, v in iocs.items():
            sizeof_key = len(v)
            iocs_size_table[k] = sizeof_key
            iocs_size += sizeof_key

        human_readable = tableToMarkdown(
            "Total of {} IOCs found in VMRay by sample {}".format(iocs_size, sample_id),
            iocs_size_table,
            headers=["URLs", "IPs", "Domains", "Mutexes", "Registry"]
        )
        return_outputs(human_readable, entry_context, raw_response=raw_response)


    try:
        COMMAND = demisto.command()
        if COMMAND == "test-module":
            # This is the call made when pressing the integration test button.
            # demisto.results('ok')
            test_module()
        elif COMMAND in ("upload_sample", "vmray-upload-sample", "file"):
            upload_sample_command()
        elif COMMAND == "vmray-get-submission":
            get_submission_command()
        elif COMMAND in ("get_results", "vmray-get-analysis-by-sample"):
            get_analysis_command()
        elif COMMAND == "vmray-get-sample":
            get_sample_command()
        elif COMMAND in ("vmray-get-job-by-sample", "get_job_sample"):
            get_job_sample_command()
        elif COMMAND == "vmray-get-job-by-id":
            get_job_by_id_command()
        elif COMMAND == "vmray-get-threat-indicators":
            get_threat_indicators_command()
        elif COMMAND == "vmray-add-tag":
            post_tags()
        elif COMMAND == "vmray-delete-tag":
            delete_tags()
        elif COMMAND == "vmray-get-iocs":
            get_iocs_command()
    except Exception as exc:
        return_error(exc.message)
  type: python
image: data:image/png;base64,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
